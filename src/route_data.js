/**
 * Port Townsend to Coupeville ("pt-cou") State Rte 20
 */
const ptSegments = [ [ 48.111141, -122.759068 ],
                     [ 48.110665, -122.758795 ],
                     [ 48.105450, -122.752322 ],
                     [ 48.105152, -122.751411 ],
                     [ 48.104947, -122.750401 ],
                     [ 48.104851, -122.749657 ],
                     [ 48.104870, -122.748516 ],
                     [ 48.105006, -122.747373 ],
                     [ 48.105202, -122.746531 ],
                     [ 48.105675, -122.745323 ],
                     [ 48.107353, -122.742506 ],
                     [ 48.135083, -122.708571 ],
                     [ 48.136311, -122.706416 ],
                     [ 48.137948, -122.703012 ],
                     [ 48.139283, -122.699387 ],
                     [ 48.139385, -122.699217 ],
                     [ 48.139437, -122.698961 ],
                     [ 48.144971, -122.684503 ],
                     [ 48.146644, -122.680799 ],
                     [ 48.148175, -122.678058 ],
                     [ 48.150366, -122.674920 ],
                     [ 48.152079, -122.673170 ],
                     [ 48.153922, -122.672039 ],
                     [ 48.155519, -122.671920 ],
                     [ 48.158876, -122.672643 ],
                     [ 48.159062, -122.672667 ] ];

/**
 * Clinton to Mukilteo (muk-cl) State Rte 525
 */
const mukSegments = [ [ 47.974796, -122.349360 ],
                      [ 47.972692, -122.347633 ],
                      [ 47.971486, -122.344723 ],
                      [ 47.968540, -122.333688 ],
                      [ 47.962225, -122.313563 ],
                      [ 47.956896, -122.301365 ],
                      [ 47.954979, -122.299519 ],
                      [ 47.954969, -122.299493 ],
                      [ 47.950761, -122.297106 ] ];

/**
 * Kingston to Edmonds (ed-king) State Rte 104
 */
const edSegments = [ [ 47.794984, -122.494545 ],
                     [ 47.792691, -122.489801 ],
                     [ 47.792365, -122.488862 ],
                     [ 47.792072, -122.487763 ],
                     [ 47.791908, -122.486768 ],
                     [ 47.790941, -122.471679 ],
                     [ 47.790953, -122.470053 ],
                     [ 47.791075, -122.468398 ],
                     [ 47.791666, -122.465110 ],
                     [ 47.792099, -122.463297 ],
                     [ 47.793045, -122.460762 ],
                     [ 47.806064, -122.435741 ],
                     [ 47.807432, -122.432947 ],
                     [ 47.808333, -122.430888 ],
                     [ 47.809277, -122.428602 ],
                     [ 47.809817, -122.426768 ],
                     [ 47.810725, -122.422637 ],
                     [ 47.811273, -122.419933 ],
                     [ 47.811979, -122.415073 ],
                     [ 47.814292, -122.392038 ],
                     [ 47.814357, -122.390150 ],
                     [ 47.814228, -122.388895 ],
                     [ 47.813969, -122.387629 ],
                     [ 47.813343, -122.385422 ] ];

/**
 * Bainbridge Island to Seattle (sea-bi) State Rte 305
 */
const biSegments = [ [ 47.622453, -122.509274 ],
                     [ 47.620197, -122.498288 ],
                     [ 47.620009, -122.497602 ],
                     [ 47.619546, -122.496700 ],
                     [ 47.619170, -122.496078 ],
                     [ 47.618331, -122.495220 ],
                     [ 47.617825, -122.494855 ],
                     [ 47.617116, -122.494469 ],
                     [ 47.608176, -122.491014 ],
                     [ 47.607757, -122.490735 ],
                     [ 47.607163, -122.490134 ],
                     [ 47.606643, -122.489362 ],
                     [ 47.606353, -122.488804 ],
                     [ 47.605934, -122.487774 ],
                     [ 47.605688, -122.486615 ],
                     [ 47.605471, -122.484770 ],
                     [ 47.605326, -122.482388 ],
                     [ 47.604169, -122.352440 ],
                     [ 47.603069, -122.343750 ],
                     [ 47.602869, -122.342291 ],
                     [ 47.602824, -122.339544 ] ];

/**
 * Bremerton to Seattle (sea-br) State Rte 304
 */
const brSegments = [ [ 47.561762, -122.624940 ],
                     [ 47.560177, -122.623438 ],
                     [ 47.559861, -122.623017 ],
                     [ 47.559713, -122.622783 ],
                     [ 47.559504, -122.622406 ],
                     [ 47.559333, -122.622044 ],
                     [ 47.559185, -122.621651 ],
                     [ 47.559029, -122.621159 ],
                     [ 47.558874, -122.620533 ],
                     [ 47.558814, -122.620244 ],
                     [ 47.558768, -122.619950 ],
                     [ 47.558693, -122.619415 ],
                     [ 47.558650, -122.618958 ],
                     [ 47.558614, -122.618494 ],
                     [ 47.558596, -122.618121 ],
                     [ 47.558588, -122.617718 ],
                     [ 47.558594, -122.617185 ],
                     [ 47.558626, -122.616555 ],
                     [ 47.558657, -122.616109 ],
                     [ 47.558704, -122.615655 ],
                     [ 47.558753, -122.615225 ],
                     [ 47.558807, -122.614851 ],
                     [ 47.558886, -122.614379 ],
                     [ 47.558987, -122.613861 ],
                     [ 47.559076, -122.613462 ],
                     [ 47.559187, -122.613027 ],
                     [ 47.559305, -122.612616 ],
                     [ 47.559436, -122.612198 ],
                     [ 47.559612, -122.611697 ],
                     [ 47.560277, -122.610194 ],
                     [ 47.560527, -122.609738 ],
                     [ 47.560689, -122.609442 ],
                     [ 47.561079, -122.608789 ],
                     [ 47.562553, -122.606775 ],
                     [ 47.582293, -122.579804 ],
                     [ 47.583561, -122.577895 ],
                     [ 47.584942, -122.575481 ],
                     [ 47.593321, -122.556333 ],
                     [ 47.593751, -122.554952 ],
                     [ 47.593909, -122.553989 ],
                     [ 47.593930, -122.553617 ],
                     [ 47.593933, -122.552931 ],
                     [ 47.593771, -122.550740 ],
                     [ 47.593621, -122.549812 ],
                     [ 47.593343, -122.548498 ],
                     [ 47.593062, -122.547467 ],
                     [ 47.592689, -122.546504 ],
                     [ 47.592266, -122.545656 ],
                     [ 47.591777, -122.544868 ],
                     [ 47.591349, -122.544377 ],
                     [ 47.590495, -122.543617 ],
                     [ 47.589377, -122.542871 ],
                     [ 47.588279, -122.542249 ],
                     [ 47.588114, -122.542182 ],
                     [ 47.576540, -122.536691 ],
                     [ 47.574765, -122.535495 ],
                     [ 47.574156, -122.534959 ],
                     [ 47.573639, -122.534378 ],
                     [ 47.571673, -122.531045 ],
                     [ 47.571084, -122.529788 ],
                     [ 47.569126, -122.524729 ],
                     [ 47.568587, -122.523026 ],
                     [ 47.568178, -122.521313 ],
                     [ 47.567898, -122.519294 ],
                     [ 47.567026, -122.509676 ],
                     [ 47.566917, -122.506435 ],
                     [ 47.566953, -122.505156 ],
                     [ 47.567044, -122.503950 ],
                     [ 47.567203, -122.502572 ],
                     [ 47.572664, -122.477479 ],
                     [ 47.574826, -122.469742 ],
                     [ 47.585901, -122.445711 ],
                     [ 47.596453, -122.420066 ],
                     [ 47.599259, -122.412755 ],
                     [ 47.601116, -122.405649 ],
                     [ 47.602228, -122.399352 ],
                     [ 47.602718, -122.391724 ],
                     [ 47.602581, -122.352085 ],
                     [ 47.602535, -122.339873 ] ];

/**
 * Adustment factor for converging longitude away from the equator.
 *
 * Lines of latitude are equidistant, but lines of longitude
 * come closer together farther from the equator. Thus longitude
 * values overstate their relative distance. Because we're in
 * a limited region, we can compensate pretty well by scaling
 * down longitude values by the cosine of our latitude.
 */
const LON_SCALE = 0.67; // ~cos(47.8 degrees = our general latitude)

/**
 * Maximum speed a vessel can have and still be considered docked.
 */
const DOCKED_SPEED = 0.5;

/**
 * Maximum distance, in nautical miles, that a vessel can be from
 * a route terminus and still be considered docked.
 */
const DOCK_DISTANCE = 0.25; // Not docked if distance > 1/4 nm from terminal

/**
 * Maximum distance, in nautical miles, that a vessel can be from
 * a route and remain associated with that route.
 */
const MAX_DISTANCE_FROM_ROUTE = 1;

/**
 * The idealized routes that WSF vessels take.
 *
 * Array[route index][waypoint index][0=latitude, 1=longitude]
 *    = latitude or longitude in degrees
 */
const routeSegments = [ ptSegments, mukSegments, edSegments, biSegments, brSegments ];

/**
 * The fraction along the route of each point in 'routeSegments'.
 *
 * The fraction at the western end (index [0]) is 0; the fraction
 * at the eastern end is 1.0.
 *
 * Array[route index][waypoint index]
 */
const routeSegmentFractions = [];

/**
 * The number of routes that this code works with
 */
const numRoutes = routeSegments.length;

/**
 * The maximum number of vessels that we will associate with
 * a ferry route.
 */
const numSlots = 2; // Maximum number of ships to track per route

/**
 * File that holds the latest associations that we have made between
 * ships and routes.
 */
const routeFileName = process.cwd() + '/ais_route_assignments.json'; // Save ship-to-route assignments

/**
 * Structure that describes our association of ships to routes
 * and each associated ship's status.
 *
 * routeAssignments:
 *     Array[route index][slot index] {
 *         isAssigned:       true if this slot has a ship assigned
 *         weakAssignment:   true if the assignment is uncertain
 *         MMSI:             ID number of the assigned ship
 *         shipName:         Ship name (without the leading 'WSF ')
 *         latestUpdate:     time of the latest position report received for this ship
 *         latestMovement:   the latest time this ship was seen moving
 *         isEastbound:      true if heading east or docked at its western terminal
 *         isDocked:         true if this ship is at a terminal
 *         progressFraction: 0.0 if at west terminal ... 1.0 if at east terminal; as of 'latestMovement'
 *         progressRate:     progressFraction change per minute (+/-)
 *     }
 */
let routeAssignments = [];

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
//  Initialization

const { writeFile } = require('fs');

//  Read 'routeAssignments' from disk
try {
    routeAssignments = require(routeFileName);
    if (routeAssignments.length != numRoutes) {
        throw new Error('Incompatible number of routes')
    }

    // Initialize all the fields that aren't saved to disk
    for (const assignment of routeAssignments) {
        for (const slot of assignment) {
            slot.latestUpdate = new Date();
            slot.latestMovement = new Date();
            slot.isEastbound = true;
            slot.isDocked = true;
            slot.progressFraction = 0;
            slot.progressRate = 0;
        }
    }
    console.log('Using saved route assignments');
} catch (err) {
    if (err.code == 'MODULE_NOT_FOUND') {
        console.log(`'${routeFileName}' does not exist`);
    } else {
        console.log(`Error reading route assignments: ${err}`);
    }
    // Regardless of what the error is, init routeAssignments
    console.log('Clearing route assignments');
    routeAssignments.length = 0;
    for (let routeIdx = 0; routeIdx < numRoutes; routeIdx++) {
        const slotArray = [];
        for (let slotIdx = 0; slotIdx < numSlots; slotIdx++) {
            slotArray.push(
                { isAssigned: false, weakAssignment: true,
                  MMSI: 0, shipName: '',
                  latestUpdate: new Date(), latestMovement: new Date(),
                  isEastBound: true, isDocked: true,
                  progressFraction: 0, progressRate: 0 });
        }
        routeAssignments.push(slotArray);
    }
    writeRouteAssignmentsToDisk();
}

makeRouteFractions();

printCurrentProgress(); // ??

// Schedule 'scrubAssignments' to run every minute
setInterval(scrubAssignments, 60 * 1000);

/**
 * Conditionally dissociates a ship from a route
 *
 *  Removes a ship from being assigned to a route if
 *  we have not recently received an update on the ship's
 *  position.
 *
 *  Marks an association as "weak" if the ship hasn't moved
 *  in over an hour.
 *
 *  This method is intended to be invoked periodically.
 */
function scrubAssignments() {
    let didSomething = false;
    const now = new Date();
    for (let routeIdx = 0; routeIdx < numRoutes; routeIdx++) {
        for (let slotIdx = 0; slotIdx < numSlots; slotIdx++) {
            if (!routeAssignments[routeIdx][slotIdx].isAssigned) {
                continue;
            }
            if (!routeAssignments[routeIdx][slotIdx].weakAssignment &&
                  ( (now - routeAssignments[routeIdx][slotIdx].latestUpdate   > (10 * 60 * 1000)) ||
                    (now - routeAssignments[routeIdx][slotIdx].latestMovement > (60 * 60 * 1000))   ))
            {
                // The assignment is strong, but we have either not received any data
                // in 10+ minutes or the ship hasn't moved in 1+ hours. Mark the assignment weak.
                console.log(`  No update or no movement: weakening association to route ` + // ??
                            `${routeIdx}, slot ${slotIdx}`); // ??
                routeAssignments[routeIdx][slotIdx].weakAssignment = true;
                didSomething = true;
            }
        }
    }
    if (didSomething) {
        writeRouteAssignmentsToDisk();
    }
    printCurrentProgress(); // ??
}

/**
 * Outputs a ship's current status
 *
 * For debug only.
 */
function printCurrentProgress() {
    console.log(`\n${hhmmss()} Route:  0                 1                 ` +
                `2                 3                 4`);
    const now = new Date();
    for (let slotIdx = 0; slotIdx < numSlots; slotIdx++) {
        logString = '         Ship:   ';
        for (let routeIdx = 0; routeIdx < numRoutes; routeIdx++) {
            const assignment = routeAssignments[routeIdx][slotIdx];
            if (!assignment.isAssigned) {
                logString += '----------        ';
            } else {
                logString += (assignment.shipName + '                  ')
                    .substring(0, 16) + '  ';
            }
        }
        console.log(logString);
        logString = '                 ';
        for (let routeIdx = 0; routeIdx < numRoutes; routeIdx++) {
            const assignment = routeAssignments[routeIdx][slotIdx];
            if (!assignment.isAssigned) {
                logString += '                  ';
            } else {
                const minutes = (now - assignment.latestUpdate) / (60 * 1000);
                let newFraction = assignment.progressFraction +
                      assignment.progressRate * minutes;
                if (newFraction < 0) newFraction = 0;
                if (newFraction > 1) newFraction = 1;
                let progressStr = Math.round(newFraction * 100) +
                    '%  ' + Number(assignment.progressRate * 100).toFixed(1) +
                    '%/min          ';
                logString += progressStr.substring(0, 16) + '  ';
            }
        }
        console.log(logString);
    }
}

/**
 * Returns a string with the current
 * time in the form ' 7:02:05'.
 *
 * For debug only.
 */
function hhmmss() {
    const now = new Date();
    let   hh = now.getHours();
    const mm = now.getMinutes();
    const ss = now.getSeconds();

    if (hh == 0) hh = 12;  // Convert from 24 hour to 12 hour format
    if (hh > 12) hh -= 12;

    let returnString = '';
    if (hh < 10) returnString += ' ';
    returnString += hh + ':';
    if (mm < 10) returnString += '0';
    returnString += mm + ':';
    if (ss < 10) returnString += '0';
    returnString += ss;

    return returnString;
}

/**
 * Writes a file with the latest associations of ships
 * to routes.
 *
 * This allows fast restart without waiting for the code
 * to deduce the associations from scratch.
 *
 * Only four fields are persistent enough to save:
 *   @isAssigned, @weakAssignment, @MMSI, @shipName
 */
function writeRouteAssignmentsToDisk() {
    const jsonString = JSON.stringify(
        routeAssignments, ['isAssigned', 'weakAssignment', 'MMSI', 'shipName' ], 2);

    writeFile(routeFileName, jsonString, (error) => {
        if (error) {
            console.log('Error writing route assignments to disk: ', error);
        }
    });
}

/**
 * For each route, creates an array that gives the
 * fraction that each point is along the way.
 *
 * Writes @routeSegmentFractions
 *
 * If there are n points,
 *   fraction [0] = 0.0 and fraction [n-1] = 1.0
 */
function makeRouteFractions() {
    routeSegmentFractions.length = 0; // Start empty
    for (let routeIdx = 0; routeIdx < numRoutes; routeIdx++) {
        const route = routeSegments[routeIdx];
        const fractions = [];
        let routeLength = 0;
        // Get the length of each segment in this route
        fractions[0] = 0;
        for (let idx = 1; idx < route.length; idx++) {
            // Get the length from point[idx] to point[idx+1]
            const deltaLat = (route[idx - 1][0] - route[idx][0]);
            const deltaLon = (route[idx - 1][1] - route[idx][1]) * LON_SCALE;
            segmentDistance = Math.sqrt(deltaLat ** 2 + deltaLon ** 2);
            fractions[idx] = segmentDistance;
            routeLength += segmentDistance;
        }
        // Divide each segment length by the total length  and sum
        // to get the fraction accumulation
        for (let idx = 1; idx < route.length; idx++) {
            fractions[idx] = fractions[idx - 1] + (fractions[idx] / routeLength);
        }
        routeSegmentFractions.push(fractions);
    }
}

export { DOCK_DISTANCE, DOCKED_SPEED, LON_SCALE, MAX_DISTANCE_FROM_ROUTE,
                   numRoutes, numSlots, routeAssignments,
                   routeSegmentFractions, routeSegments,
                   writeRouteAssignmentsToDisk };
